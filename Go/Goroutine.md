- 동시성(Concurreny)은 단일 프로세스를 독립적인 컴포넌트로 분리하고 해당 컴포넌트가 안전하게 데이터를 공유하는 방법

### 동시성 사용 시점
---
- 동시성은 병렬성이 아니다 (Concurreny is not parallelism)
- 동시성 코드가 병렬적으로 실행되는지 여부는 하드웨어와 알고리즘이 허용하는지 여부에 따라 다름
- 동시성의 사용 여부는 데이터 흐름에 따라 결정됨
- 동시성은 동시에 실행되는 것이 시간이 얼마 걸리지 않을 때는 사용하는 것이 좋지 않다
	- 동시성은 공짜가 아니며, 많은 in-memory 알고리즘은 너무 빨라서 동시성 코드를 수행하여 얻는 잠재적 시간절약을 압도
	- 동시성 수행은 보통 I/O 작업을 위해 사용

### 고루틴(Goroutine)
---
- 프로세스(Process): 컴퓨터의 운영체제에서 수행 중인 프로그램의 인스턴스, 하나 이상의 스레드로 구성
- 스레드(Thread): 운영체제가 주어진 시간동안 수행되는 실행의 단위

고루틴(Goroutine)은 Go 런타임에서 관리하는 가벼운 ~~프로세스 (책의 오역)~~ 스레드이다.

- Go 프로그램이 실행되면, Go 런타임은 여러 스레드를 생성하고 단일 고루틴 시작
- 모든 고루틴은 운영체제에서 CPU 코어에 따라 Go 런타임 스케줄러가 자동으로 스레드들을 할당
- 기본 운영체제 시스템이 프로세스와 스레드를 관리하는 스케줄러를 이미 갖고 있어서, 추가 작업처럼 보이지만 이점 존재
	- 고루틴 생성은 운영체제 레벨 자원 생성이 아니기 때문에 스레드 생성보다 빠르다
	- 고루틴의 초기 스택 크기는 스레드의 스택 크기보다 작으며 필요하다면 늘릴 수 있음
	- 고루틴 간 전환은 완전히 프로세스 내에서 일어나서 느린 운영체제 시스템 호출을 회피하기 때문에 스레드 사이의 전환보다 빠르다

- 고루틴은 함수의 실행 전에 `go`키워드로 시작
- 다른 함수들과 같이, 상태를 초기화하기 위해 파라미터 전달 가능, but 함수에서 반환되는 모든 값은 무시
- 내부에 비즈니스 로직이 있는 closure를 고루틴으로 실행하는 것이 Go에서는 관례적

### 채널(Channel)
---
- 고루틴은 채널을 통해 통신
- `make` 함수를 사용하여 생성
```go
ch := make(chan int)
```

**읽기, 쓰기 그리고 버퍼링**

- `<-` 연산자를 사용하여 채널과 상호작용
```go
a := <-ch // ch에서 값을 읽어 a에 할당
ch <- b // b의 값을 ch에 쓴다
```
- 채널에 쓰여진 값은 한 번에 하나씩 읽을 수 있으며, 다중 고루틴이 같은 채널에서 읽기를 한다면 채널에 쓰인 하나의 값은 다중 고루틴 중 하나만 읽을 수 있음
- 기본적으로 채널은 버퍼가 없다
	- 버퍼가 없는 열린 채널에 쓰기를 할 때마다 다른 고루틴에서 같은 채널을 읽을 때까지 해당 고루틴은 일시 중지 상태
	- 버퍼가 없는 열린 채널에 읽기를 하면 다른 고루틴에서 같은 채널에 쓰기를 할 때까지 해당 고루틴은 일시 중지 상태
- 버퍼가 있는 채널(buffered channel)도 있다
	- 블로킹 없이 제한된 쓰기의 버퍼를 가지며, 버퍼가 다 채워지면, 채널이 읽어질 때까지 쓰기 고루틴은 일시 중지 상태
- 대부분의 경우 버퍼가 없는 채널 사용

**for-range와 채널**
- `for-range` 루프를 이용하여 채널의 값을 읽을 수 있음

**채널 닫기**
- 채널에 쓰기를 완료했을 때, `close` 내장 함수를 이용해 채널을 닫을 수 있다
- 채널을 닫으면 채널에 쓰기를 시도하거나 다시 닫으려 한다면 패닉 발생
- 닫힌 채널에 읽기를 시도하는 것은 언제나 성공
- 채널을 닫아야 하는 책임은 채널에 쓰기를 하는 고루틴에 있다

**채널 동작 방식**
- Go 프로그램이 패닉 상태로 가는 것은 반드시 피해야 하며, 더 이상 채널에 쓸 내용이 없을 때, 쓰기 고루틴에서 채널을 close 해야함
- 하나의 고루틴에서 채널을 닫았을 때, 다른 고루틴에서 쓰기를 진행하면 패닉이 발생하는데, 이 때 `sync.WaitGroup`을 사용하여 해결

### `select` 문
---
- `select`는 Go에서 동시성을 제어하기 위한 제어 구조
- 두 개의 동시성 연산을 수행할 때, 하나를 선호할 수도 있고, 어떤 경우를 처리하지 않는 기아(starvation) 상태 발생 가능
- `select` 키워드는 여러 채널의 세트 중 하나에 읽기를 하거나 쓰기를 할 수 있는 고루틴 허용
```go
select {
case v := <-ch:
	fmt.Println(v)
case v := <-ch2:
	fmt.Println(v)
case ch3 <- x:
	fmt.Println("wrote", x)
}
```
- 여러 case에 읽거나 쓸 수 있는 채널이 있는 경우 하나를 임의로 선택하며, 순서는 중요하지 않다
- `select` 임의 선택의 장점은 교착 상태를 빠지게 할 수 있는 일관성 없는 순서로 lock 획득 방지
- `select`는 여러 채널을 통한 통신을 담당하기 때문에 `for` 루프에 임베딩 된다